'''
simulator.py
Author: Andrew Gaylord, Sophie, Rawan, Rene, Chau, Daniel, Brian

Contains simulator class for NearSpace detumble and point simulation
Object contains system info, initialized values, state values, and all outputs
Class functions allow for easy initialization, propagation, data generation, simulation, and visualization

All parameters (variables in caps) are stored in *params.py*

'''


# from Simulator.PySOL.wmm import *
from Horizon_Sensor_Sim.Simulator.visualizer import *
import time
from Horizon_Sensor_Sim.Simulator.graphing import *
from Horizon_Sensor_Sim.Simulator.saving import *

import os
import sys

# import params module from parent directory
sys.path.insert(1, os.path.join(sys.path[0], '..'))
from Horizon_Sensor_Sim.params import *
from Horizon_Sensor_Sim.Simulator.sat_model import Magnetorquer_Sat
from Horizon_Sensor_Sim.Simulator.all_EOMs import *
from Horizon_Sensor_Sim.Simulator.image_processing import *
from Horizon_Sensor_Sim.Simulator.B_dot import *
from Horizon_Sensor_Sim.Simulator.nadir_point import *
import math

class Simulator():
    def __init__ (self, mag_sat, b_earth):
        # number of steps to simulate
        self.n = int(TF / DT)
        # timestep between steps
        self.dt = DT

        # satellite model to use for simulation
        self.mag_sat = mag_sat

        # dimension of state and measurement space
        self.dim = STATE_SPACE_DIMENSION
        self.dim_mes = MEASUREMENT_SPACE_DIMENSION
        
        # current velocity is stored in mag_sat
        #self.velocity = [mag_sat[0].w_sat, mag_sat[1].w_sat, mag_sat[2].w_sat] # create array storing angular velocity vector
        # current quaternion
        self.quaternion = normalize(QUAT_INITIAL)

        # # starting state (default is standard quaternion and no angular velocity)
        # self.state = np.concatenate((normalize(QUAT_INITIAL), VELOCITY_INITIAL))

        # noise arrays for magnetometer and gyroscope
        if SENSOR_NOISE:
            magSD = SENSOR_MAGNETOMETER_SD
            self.magNoises = np.random.normal(0, magSD, (self.n, 3))
            
            gyroSD = SENSOR_GYROSCOPE_SD
            self.gyroNoises = np.random.normal(0, gyroSD, (self.n, 3))
        else:
            self.magNoises = np.zeros((self.n, 3))
            self.gyroNoises = np.zeros((self.n, 3))

        # true magnetic field for every timestep in simulation
        if CONSTANT_B_FIELD:
            # magnetic field in earth and body frame in microTeslas
            self.B_earth = np.full((self.n, 3), CONSTANT_B_FIELD_MAG)
            self.B_body = np.full((self.n, 3), np.matmul(quaternion_rotation_matrix(self.quaternion), CONSTANT_B_FIELD_MAG))
        else:
            # record 2D array of magnetic field of earth for every timestep
            self.B_earth = b_earth
            # initialize array of magnetic field in the body frame and find first element
            # microteslas, noisy
            self.B_body = np.zeros((self.n, 3))
            # first element of B_body is set by generate_data_step(0)

        # current to magnetorquers for all n steps
        self.currents = np.zeros((self.n, 3))
        self.currents[0] = CURRENTS_INITIAL
        # voltages to magnetorquers for all n steps
        self.voltages = np.zeros((self.n, 3))
        self.voltages[0] = VOLTAGES_INITIAL

        # simulated torque generated by magnetorquers for all n steps
        self.torques = np.zeros((self.n, 3))

        # add a new array storing power output
        self.power_output = np.zeros((self.n, 3))
        init_power = [dimension*dimension/RESISTANCE_MAG for dimension in VOLTAGES_INITIAL] # power = Watts being used at this particular time = V^2 / R
        self.power_output[0] = init_power # set initial power output based on initial current output, voltage
        self.totalPower = np.zeros((self.n)) # set total power per time step to 0

        # data values for all n steps
        self.data = np.zeros((self.n, self.dim_mes))

        # state (orentiation + angular velocity) for all n steps
        self.states = np.zeros((self.n, self.dim))
        self.states[0] = np.concatenate((normalize(QUAT_INITIAL), VELOCITY_INITIAL))

        # time taken for each step (for efficiency testing)
        self.times = np.zeros(self.n)

        # generate data for first step
        # populates self.B_body[0], self.data[0], self.mag_sat.B_body, and self.mag_sat.w_sat
        self.generateData_step(self.states[0], 0)

        # time for when angular velocity slowed down to 0-0.5 degrees per axis in seconds
        self.finishedTime = -1
        # self.finishedTime/3600 is time in hours

        # pitch and roll for cam 1 and 2, respectively
        self.pitches1 = np.zeros((self.n))
        self.rolls1 = np.zeros((self.n))
        self.pitches2 = np.zeros((self.n))
        self.rolls2 = np.zeros((self.n))
        # edge arrays for cam 1 and 2
        self.edges1 = np.zeros((self.n, 4))
        self.edges2 = np.zeros((self.n, 4))

        # what mode we're in for each time step
        # "detumble" = -2, "search" = -1, "point" = [0, 1] (based on which cam we're trusting. 1 = cam1, 0 = cam2)
        self.mode = np.zeros((self.n))
        
        # Set the total energy to 0 at the start (joules)
        self.energy = 0


    def find_ideal(self, i):
        '''
        Find the "ideal" next state using physics EOMs based on our last state
        Used so we can generate more occurate data for that step
        '''
        q_dot, w_dot = eoms(self.states[i-1][:4], self.states[i-1][4:], 0, self.torques[i-1], 0, self.dt, self.mag_sat.I_body, 0)

        # propagate state using Euler's method
        quat = normalize(self.states[i-1][:4] + q_dot*self.dt)
        velocity = self.states[i-1][4:] + w_dot*self.dt

        return np.concatenate((quat, velocity))


    def propagate_step(self, i):
        '''
        Based on our last state and voltage output from our controls (voltages[i]), progate through our EOMs to get the next state
        Populates self.states[i], our current current orientation and velocity at the end of the timestep
        '''

        # find current generated by voltage output by last time step
        # Our torquers take time to reach desired current according to EOM:
        #    di/dt = (V_in - i*R) / L
        # i_dot = (self.voltages[i] - self.currents[i - 1] * RESISTANCE_MAG) / INDUCTANCE_MAG
        i_dot = (self.voltages[i] - self.currents[i - 1] * self.mag_sat.resistances) / self.mag_sat.inductances

        # propagate our current (find for this time step) using Euler's method
        currents = self.currents[i - 1] + i_dot * DT
        currents = np.clip(currents, -MAX_CURRENT, MAX_CURRENT)
        
        # find the magnetic moment generated by those currents (A*m^2)
        moment = currents * np.array([mag.n * mag.area * mag.epsilon for mag in self.mag_sat.mags])

        # note: we want to use true body magnetic field of last iteration, not noisy sensor reading
        true_b_body = self.mag_sat.B_body - (self.magNoises[i] * 1e-6)

        # torque (N*m) generated by magnetorquers: cross-product of moment with magnetic field
        torque = np.cross(moment, true_b_body)

        # limit mag torques based on type (ferro or air)
        # torque = np.clip(torque, -self.mag_sat.max_torque, self.mag_sat.max_torque)

        # calculate power output of magnetorquers = current output * operational voltage
        # power = Watts being used at this particular time
        power = np.abs(MAX_VOLTAGE * currents)
        # or V^2 / R??
        # power = np.abs(self.voltages[i] * self.voltages[i] / RESISTANCE_MAG)
        
        # store sim data for this iteration
        self.power_output[i] = np.array(power)
        self.currents[i] = np.array(currents)
        self.torques[i] = np.array(torque)
        
        # calculate quaternion and angular velocity derivatives from Equations of Motion
        q_dot, w_dot = eoms(self.states[i-1][:4], self.states[i-1][4:], 0, torque, 0, DT, self.mag_sat.I_body, 0)
        # propagate state using Euler's method
        # find next state in time (based on current state, not sensor data)
        quaternion_new = normalize(self.states[i-1][:4] + q_dot*DT)
        w_sat_new = self.states[i-1][4:] + w_dot*DT

        self.states[i] = np.concatenate((quaternion_new, w_sat_new))

        return self.states[i]
    

    def generateData_step(self, ideal, i):
        '''
        Generates fake data for a single time step and populates self.data[i], self.B_body[i]
            Sets mag_sat.B_body and mag_sat.w_sat to simulated sensor readings
        Adds noise to the ideal states to mimic what our sensors would be giving us

        @returns:
            data: array of sensor fake data (1 x dim_mes)
        '''

        data = np.zeros(self.dim_mes)

        # calculate sensor b field for current time step (see h func for more info on state to measurement space conversion)
        # use current B field of earth to transform ideal state to measurement space + add noise
        # rotation matrix(q) * true B field + noise (in microteslas)
        self.B_body[i] = np.matmul(quaternion_rotation_matrix(ideal[:4]), self.B_earth[i]) + self.magNoises[i]
        
        # Set the previous B field to current B field before future B field is calculated
        # Only set previous B field when step is greater than 0 (edge case)
        if i > 0:
            self.mag_sat.prevB = self.mag_sat.B_body
        
        # store new reading in our sat object
        self.mag_sat.B_body = self.B_body[i].astype(np.float64)
        
        # convert from microteslas to teslas
        self.mag_sat.B_body = np.array([self.mag_sat.B_body[0] * 1e-6, self.mag_sat.B_body[1] * 1e-6, self.mag_sat.B_body[2] * 1e-6])

        data[:3] = self.B_body[i]

        # get predicted speed of this state + noise (in rad/s) to mimic gyro reading
        data[3] = ideal[4] + self.gyroNoises[i][0]
        data[4] = ideal[5] + self.gyroNoises[i][1]
        data[5] = ideal[6] + self.gyroNoises[i][2]
        # set the angular velocity reading of the satellite
        self.mag_sat.w_sat = np.array([data[3], data[4], data[5]])

        # store in data array
        self.data[i] = data

        return data


    def process_images(self, image1, image2, i):
        '''
        Takes in our two simulated EHS images and stores the info in mag_sat object
        '''

        self.mag_sat.cam1.roll, self.mag_sat.cam1.pitch, self.mag_sat.cam1.alpha, self.mag_sat.cam1.edges = processImage(image1)
        self.pitches1[i] = self.mag_sat.cam1.pitch
        self.rolls1[i] = self.mag_sat.cam1.roll
        self.edges1[i] = self.mag_sat.cam1.edges
        # because we're simulating every other cam, set same measurements for next time step
        self.pitches1[i + 1] = self.mag_sat.cam1.pitch
        self.rolls1[i + 1] = self.mag_sat.cam1.roll
        self.edges1[i + 1] = self.mag_sat.cam1.edges

        self.mag_sat.cam2.roll, self.mag_sat.cam2.pitch, self.mag_sat.cam2.alpha, self.mag_sat.cam2.edges = processImage(image2)
        self.pitches2[i] = self.mag_sat.cam2.pitch
        self.rolls2[i] = self.mag_sat.cam2.roll
        self.edges2[i] = self.mag_sat.cam2.edges
        # because we're simulating every other cam, set same measurements for next time step
        self.pitches2[i + 1] = self.mag_sat.cam2.pitch
        self.rolls2[i + 1] = self.mag_sat.cam2.roll
        self.edges2[i + 1] = self.mag_sat.cam2.edges
        # print("alphas: {} {}".format(self.mag_sat.cam1.alpha, self.mag_sat.cam2.alpha))


    def check_state(self, i):
        '''
        Checks current state of our mag_sat and updates if requirements are met
        If detumbling, check threshold speed
        If searching, check if horizon is found
        If pointing, check if horizon is lost
            Also always check if speed is too high??
        
        '''
        if self.mag_sat.state == "detumble":
            # threshold 0.5-1 degress per second per axis
            thresholdLow = 0
            thresholdHigh = DETUMBLE_THRESHOLD

            angularX = abs(self.states[i - 1][4])
            angularY = abs(self.states[i - 1][5])
            angularZ = abs(self.states[i - 1][6])

            # if we're below threshold, move to horizon search
            if (thresholdLow <= angularX <= thresholdHigh) and (thresholdLow <= angularY <= thresholdHigh) and (thresholdLow <= angularZ <= thresholdHigh):

                if(self.finishedTime == -1):
                    print("Successfully detumbled after " + str(i*self.dt) + " seconds!")
                    # record first time we hit "detumbled" threshold (seconds)
                    self.finishedTime = i*DT
                    
                    # When the "detumbled" threshold is hit, calculate total Energy
                    # Total Energy is calculated as a "Rieman Sum" of the total power used at each time step multiplied by the time step
                    for step in range(i):
                        self.energy = self.energy + self.totalPower[step]*self.dt
                
                # move to horizon searching protocol
                return "search"

            return "detumble"

        elif self.mag_sat.state == "search":
            # if both see earth in some capacity (even if one if full), move to pointing
            if self.mag_sat.cam1.alpha >= 0.05 and self.mag_sat.cam2.alpha >= 0.05:
                # print("SWITCH TO POINT")
                return "point"
            else:
                # if we don't see the earth, check that we're below detumble threshold
                return "detumble"

            # count to see how long we've been waiting for??
        elif self.mag_sat.state == "point":
            # check if we lost horizon--move to search
            if (0.0 <= self.mag_sat.cam1.alpha <= 0.05) or (0.0 <= self.mag_sat.cam2.alpha <= 0.05):
                return "search"
            else:
                return "point"
        else:
            return "INVALID"

    
    def controls(self, i):
        '''
        Based on saved sensor data and current protocol state, generate correct controls voltages
        Voltage for next step is stored in self.voltages[i]
        Info about what mode we're in is stored in self.mode[i]
        '''
        if self.mag_sat.state == "detumble":
            # oppose angular velocity
            self.voltages[i] = B_dot(self.mag_sat)
            self.mode[i] = -2
        elif self.mag_sat.state == "search":
            # do nothing while horizon searching, for now
            self.voltages[i] = np.zeros((3))
            self.mode[i] = -1
        elif self.mag_sat.state == "point":
            # process images and try to center cams
            if i % 2 == 0:
                # only take an image every other timestep
                # get voltage output and what mode we're in based on image results
                self.voltages[i], self.mode[i] = nadir_point(self.mag_sat)
                self.voltages[i] = np.clip(self.voltages[i], -MAX_VOLTAGE, MAX_VOLTAGE)
            else:
                self.voltages[i] = self.voltages[i - 1]
                self.mode[i] = self.mode[i - 1]


    def plotData(self):
        '''
        plots the magnetometer (magData.png) and gyroscope data (magData.png) found in self.data
        '''
        plotData_xyz(self.data)
        # also plot b field of earth
        plot_xyz(self.B_earth, "Earth's Magnetic Field (ECI frame from PySOL)", fileName="B_earth.png", ylabel="Magnetic Field (microteslas)")
        plot_multiple_lines([self.pitches1, self.rolls1, self.pitches2, self.rolls2],["Pitch1", "Roll1", "Pitch2", "Roll2"], "Image Processing",fileName="Pitch_Roll.png",ylabel="Angle (Degrees)")
        plot_multiple_lines([self.edges1[:, 0], self.edges1[:, 1], self.edges1[:, 2], self.edges1[:, 3]],["Top", "Right", "Bottom", "Left"], "Edge Intensities 1",fileName="Edges1.png",ylabel="Relative %")
        plot_multiple_lines([self.edges2[:, 0], self.edges2[:, 1], self.edges2[:, 2], self.edges2[:, 3]],["Top", "Right", "Bottom", "Left"], "Edge Intensities 2",fileName="Edges2.png",ylabel="Relative %")


    def plotStates(self):
        '''
        plots the states found in self.states
        also also plots the euler angle of our state (with respect to our starting state)
        '''
        plotState_xyz(self.states)
        plot_multiple_lines([self.mode], ["Mode"], "Satellite Mode", fileName="Mode.png", ylabel="Mode")
        # unpack the filtered quaternion and convert it to euler angles
        # use the error quaternion between our starting state and current state to base angle off of starting point
        # plotAngles(np.array([euler_from_quaternion(*delta_q(a[:4], QUAT_INITIAL)) for a in self.states]), "Euler angles", fileName="Euler.png")


    def plotMagInfo(self):
        '''
        Plots the currents and torque created by our magnetorquers
        '''
        plot_xyz(self.voltages, "Voltages", fileName="Voltages.png", ylabel="Voltage (Volts)")
        plot_xyz(self.currents, "Currents", fileName="Currents.png", ylabel="Current (Amps)")
        plot_xyz(self.torques, "Torques", fileName="Torques.png", ylabel="Torque (N*m)")
        plot_xyz(self.power_output, "Power Usage", fileName="Power_Output.png", ylabel="Power (Watts)")
        # plot_multiple_lines([self.totalPower],["Total Power"], "Total Power Output",fileName="Total_Power_Output.png",ylabel="Power (Watts)")


    def plot_and_viz_results(self):
        '''
        Plots out filter states, data, and reaction wheel speeds, and creates pdf output + 3D visualization
        Allows us to visualize results of our filter/controls sim
        Based upon RESULT variable in params.py
        '''

        # clear output directory from last simulation
        clearDir(OUTPUT_DIR)

        # plot mag and gyro data
        self.plotData()
        # plots states
        self.plotStates()
        # plot magnetorquer info
        self.plotMagInfo()

        # 0 = only create pdf output, 1 = show 3D animation visualization, 2 = both, 3 = none
        visualize = RESULT

        if visualize == 1:
            self.visualizeResults(self.states)

        elif visualize == 0:

            self.saveFile(OUTPUT_FILE)

        elif visualize == 2:

            self.saveFile(OUTPUT_FILE)

            self.visualizeResults(self.states)

        # only show plot at end so they all show up
        # plt.show()


    def saveFile(self, fileName):
        '''
        takes all saved pngs and compiles a pdf with the given fileName
        uses the formating function found within saving.py
        stores in OUTPUT_DIR variable declared in params.py and opens completed file
        only prints tests results of printsTests is True
        '''

        # savePNGs(OUTPUT_DIR)

        savePDF(fileName, OUTPUT_DIR, self)

        # openFile(fileName)


    def visualizeResults(self, states, i = 0):
        '''
        Given an array of states, visualize the cubesat moving in 3D
        '''

        game_visualize(np.array(states), i)
    
