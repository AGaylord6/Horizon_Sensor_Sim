'''
simulator.py
Author: Andrew Gaylord, Sophie, Rawan, Rene, Chau, Daniel, Brian

Contains simulator class for NearSpace detumble and point simulation
Object contains system info, initialized values, state values, and all outputs
Class functions allow for easy initialization, propagation, data generation, simulation, and visualization

All parameters (variables in caps) are stored in *params.py*

'''


# from Simulator.PySOL.wmm import *
from Simulator.visualizer import *
import time
from Simulator.graphing import *
from Simulator.saving import *

import os
import sys

# import params module from parent directory
sys.path.insert(1, os.path.join(sys.path[0], '..'))
from params import *
from propagate import *
from sat_model import Magnetorquer_Sat
from all_EOMs import *
import math

class Simulator():
    def __init__ (self, mag_sat, b_earth):
        # number of steps to simulate
        self.n = int(TF / DT)
        # timestep between steps
        self.dt = DT

        # satellite model to use for simulation
        self.mag_sat = mag_sat

        # dimension of state and measurement space
        self.dim = STATE_SPACE_DIMENSION
        self.dim_mes = MEASUREMENT_SPACE_DIMENSION
        
        # current velocity is stored in mag_sat
        #self.velocity = [mag_sat[0].w_sat, mag_sat[1].w_sat, mag_sat[2].w_sat] # create array storing angular velocity vector
        # current quaternion
        self.quaternion = QUAT_INITIAL

        # # starting state (default is standard quaternion and no angular velocity)
        # self.state = np.concatenate((normalize(QUAT_INITIAL), VELOCITY_INITIAL))

        # noise arrays for magnetometer and gyroscope
        if SENSOR_NOISE:
            magSD = SENSOR_MAGNETOMETER_SD
            self.magNoises = np.random.normal(0, magSD, (self.n, 3))
            
            gyroSD = SENSOR_GYROSCOPE_SD
            self.gyroNoises = np.random.normal(0, gyroSD, (self.n, 3))
        else:
            self.magNoises = np.zeros((self.n, 3))
            self.gyroNoises = np.zeros((self.n, 3))

        # true magnetic field for every timestep in simulation
        if CONSTANT_B_FIELD:
            # magnetic field in earth and body frame in microTeslas
            self.B_earth = np.full((self.n, 3), CONSTANT_B_FIELD_MAG)
            self.B_body = np.full((self.n, 3), np.matmul(quaternion_rotation_matrix(self.quaternion), CONSTANT_B_FIELD_MAG))
        else:
            # record 2D array of magnetic field of earth for every timestep
            self.B_earth = b_earth
            # initialize array of magnetic field in the body frame and find first element
            # microteslas, noisy
            self.B_body = np.zeros((self.n, 3))
            # first element of B_body is set by generate_data_step(0)

        # current to magnetorquers for all n steps
        self.currents = np.zeros((self.n, 3))
        self.currents[0] = CURRENTS_INITIAL

        # simulated torque generated by magnetorquers for all n steps
        self.torques = np.zeros((self.n, 3))

        # add a new array storing power output
        self.power_output = np.zeros((self.n, 3))
        init_power = [MAX_VOLTAGE*dimension for dimension in CURRENTS_INITIAL] # power = Watts being used at this particular time
        self.power_output[0] = init_power # set initial power output based on initial current output, voltage
        self.totalPower = np.zeros((self.n)) # set total power per time step to 0

        # data values for all n steps
        self.data = np.zeros((self.n, self.dim_mes))

        # state (orentiation + angular velocity) for all n steps
        self.states = np.zeros((self.n, self.dim))
        self.states[0] = np.concatenate((normalize(QUAT_INITIAL), VELOCITY_INITIAL))

        # time taken for each step (for efficiency testing)
        self.times = np.zeros(self.n)

        # generate data for first step
        # populates self.B_body[0], self.data[0], self.mag_sat.B_body, and self.mag_sat.w_sat
        self.generateData_step(self.states[0], 0)

        # time for when angular velocity slowed down to 0-0.5 degrees per axis in seconds
        self.finishedTime = -1
        # self.finishedTime/3600 is time in hours
        
        # Set the total energy to 0 at the start (joules)
        self.energy = 0


    def find_ideal(self, i):
        '''
        Find the "ideal" next state using physics EOMs based on our last state
        Used so we can generate more occurate data for that step
        '''
        q_dot, w_dot = eoms(self.states[i-1][:4], self.states[i-1][4:], 0, self.torques[i-1], 0, self.dt, self.mag_sat.I_body, 0)

        # propagate state using Euler's method
        quat = normalize(self.states[i-1][:4] + q_dot*self.dt)
        velocity = self.states[i-1][4:] + w_dot*self.dt

        return np.concatenate((quat, velocity))


    def propagate_step(self, i):
        '''
        Based on our last state, progate through our EOMs to get the next state
        Populates self.states[i], allowing us to generate realistic data
        '''

        quat, velocity = propagate(self.states[i-1][:4], self.states[i-1][4:], self.mag_sat, self.currents[i-1], self.dt, self, i)

        self.states[i] = np.concatenate((quat, velocity))

        return self.states[i]
    

    def generateData_step(self, ideal, i):
        '''
        Generates fake data for a single time step and populates self.data[i], self.B_body[i]
            Sets mag_sat.B_body and mag_sat.w_sat to simulated sensor readings
        Adds noise to the ideal states to mimic what our sensors would be giving us

        @returns:
            data: array of sensor fake data (1 x dim_mes)
        '''

        data = np.zeros(self.dim_mes)

        # calculate sensor b field for current time step (see h func for more info on state to measurement space conversion)
        # use current B field of earth to transform ideal state to measurement space + add noise
        # rotation matrix(q) * true B field + noise (in microteslas)
        self.B_body[i] = np.matmul(quaternion_rotation_matrix(ideal[:4]), self.B_earth[i]) + self.magNoises[i]
        
        # Set the previous B field to current B field before future B field is calculated
        # Only set previous B field when step is greater than 0 (edge case)
        if i > 0:
            self.mag_sat.prevB = self.mag_sat.B_body
        
        # store new reading in our sat object
        self.mag_sat.B_body = self.B_body[i].astype(np.float64)
        
        # convert from microteslas to teslas
        self.mag_sat.B_body = np.array([self.mag_sat.B_body[0] * 1e-6, self.mag_sat.B_body[1] * 1e-6, self.mag_sat.B_body[2] * 1e-6])

        data[:3] = self.B_body[i]

        # get predicted speed of this state + noise (in rad/s) to mimic gyro reading
        data[3] = ideal[4] + self.gyroNoises[i][0]
        data[4] = ideal[5] + self.gyroNoises[i][1]
        data[5] = ideal[6] + self.gyroNoises[i][2]
        # set the angular velocity reading of the satellite
        self.mag_sat.w_sat = np.array([data[3], data[4], data[5]])

        # store in data array
        self.data[i] = data

        return data


    def run_b_dot_sim(self):
        '''
        Simulates the B_dot detumbling algorithm
        '''
        i = 1

        while i < self.n:
            ideal = self.find_ideal(i)

            # generate fake sensor data in body frame based on last state
            self.generateData_step(ideal, i)

            self.propagate_step(i)

            # calculate total power usage for this time step (Watts)
            self.totalPower[i] = self.power_output[i][0] + self.power_output[i][1] + self.power_output[i][2]

            # threshold 0.5-1 degress per second per axis
            thresholdLow = 0
            thresholdHigh = DETUMBLE_THRESHOLD

            angularX = abs(self.states[i][4])
            angularY = abs(self.states[i][5])
            angularZ = abs(self.states[i][6])

            if(self.finishedTime == -1):
                if (thresholdLow <= angularX <= thresholdHigh) and (thresholdLow <= angularY <= thresholdHigh) and (thresholdLow <= angularZ <= thresholdHigh):
                    # record first time we hit "detumbled" threshold (seconds)
                    self.finishedTime = i*DT
                    
                    # When the "detumbled" threshold is hit, calculate total Energy
                    # Total Energy is calculated as a "Rieman Sum" of the total power used at each time step multiplied by the time step
                    for step in range(i):
                        self.energy = self.energy + self.totalPower[step]*self.dt
                    
            i += 1
        
        self.plot_and_viz_results()


    def plotData(self):
        '''
        plots the magnetometer (magData.png) and gyroscope data (magData.png) found in self.data
        '''
        plotData_xyz(self.data)
        # also plot b field of earth
        plot_xyz(self.B_earth, "Earth's Magnetic Field (ECI frame from PySOL)", fileName="B_earth.png", ylabel="Magnetic Field (microteslas)")


    def plotStates(self):
        '''
        plots the states found in self.states
        also also plots the euler angle of our state (with respect to our starting state)
        '''
        plotState_xyz(self.states)
        # unpack the filtered quaternion and convert it to euler angles
        # use the error quaternion between our starting state and current state to base angle off of starting point
        plotAngles(np.array([euler_from_quaternion(*delta_q(a[:4], QUAT_INITIAL)) for a in self.states]), "Euler angles", fileName="Euler.png")
        # plotAngles(np.array([euler_from_quaternion(*a[:4]) for a in self.filtered_states]), "Euler angles", fileName="Euler.png")


    def plotMagInfo(self):
        '''
        Plots the currents and torque created by our magnetorquers
        '''
        plot_xyz(self.currents, "Currents", fileName="Currents.png", ylabel="Current (Amps)")
        plot_xyz(self.torques, "Torques", fileName="Torques.png", ylabel="Torque (N*m)")
        plot_xyz(self.power_output, "Power Usage", fileName="Power_Output.png", ylabel="Power (Watts)")
        plot_multiple_lines([self.totalPower],["Total Power"], "Total Power Output",fileName="Total_Power_Output.png",ylabel="Power (Watts)")


    def plot_and_viz_results(self):
        '''
        Plots out filter states, data, and reaction wheel speeds, and creates pdf output + 3D visualization
        Allows us to visualize results of our filter/controls sim
        Based upon RESULT variable in params.py
        '''

        # clear output directory from last simulation
        clearDir(OUTPUT_DIR)

        # plot mag and gyro data
        self.plotData()
        # plots states
        self.plotStates()
        # plot magnetorquer info
        self.plotMagInfo()

        # 0 = only create pdf output, 1 = show 3D animation visualization, 2 = both, 3 = none
        visualize = RESULT

        if visualize == 1:
            self.visualizeResults(self.states)

        elif visualize == 0:

            self.saveFile(OUTPUT_FILE)

        elif visualize == 2:

            self.saveFile(OUTPUT_FILE)

            self.visualizeResults(self.states)

        # only show plot at end so they all show up
        plt.show()


    def saveFile(self, fileName):
        '''
        takes all saved pngs and compiles a pdf with the given fileName
        uses the formating function found within saving.py
        stores in OUTPUT_DIR variable declared in params.py and opens completed file
        only prints tests results of printsTests is True
        '''

        # savePNGs(OUTPUT_DIR)

        savePDF(fileName, OUTPUT_DIR, self)

        openFile(fileName)


    def visualizeResults(self, states, i = 0):
        '''
        Given an array of states, visualize the cubesat moving in 3D
        '''

        game_visualize(np.array(states), i)
    
