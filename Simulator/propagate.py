'''
Propagate.py

Using to simulate how our satellite would behave in space under the effect of certain currents being applied to our magnetorquers

'''
import numpy as np

from Horizon_Sensor_Sim.Simulator.B_dot import B_dot
from Horizon_Sensor_Sim.Simulator.all_EOMs import eoms, normalize
from Horizon_Sensor_Sim.Simulator.sat_model import Magnetorquer_Sat
from Horizon_Sensor_Sim.params import FERRO_MAX_TORQUE, MAX_VOLTAGE, MAX_CURRENT, RESISTANCE_MAG, INDUCTANCE_MAG, AIR_MAX_TORQUE

def propagate(quaternion: np.ndarray, velocity: np.ndarray, mag_sat: Magnetorquer_Sat, prev_current: np.ndarray, dt: float, sim=None, iteration=None):
    '''
    Propagates our quatertion and angulare velocities using our EOMs and Euler's method

    @params:
        quaternion: current attitude
        velocity: current simulated angular velocity (without noise)
        mag_sat: Magnetoquer_Sat object with what it thinks it's angular velocity and b field is (sensor reading)
        prev_current: previous current of magnetorquers circuit
        dt: timestep
        sim (optional): Simulator object to store results in for graphing
        iteration (optional): current time step

    @returns:
        queternion_new: predicted attitude
        w_sat_new: predicted angular velocities
    '''
    # generate voltage (volts) needed to counteract angular velocity
    voltage_in = B_dot(mag_sat)
    # make sure voltage is within bounds
    voltage_in = np.clip(voltage_in, -MAX_VOLTAGE, MAX_VOLTAGE)

    # find current generated by that voltage
    # Our torquers take time to reach desired current according to EOM:
    #    di/dt = (V_in - i*R) / L
    i_dot = (voltage_in - prev_current * RESISTANCE_MAG) / INDUCTANCE_MAG

    # propagate our current (find for this time step) using Euler's method
    currents = prev_current + i_dot * dt
    currents = np.clip(currents, -MAX_CURRENT, MAX_CURRENT)
    
    # find the magnetic moment generated by those currents (A*m^2)
    moment = currents * np.array([mag.n * mag.area * mag.epsilon for mag in mag_sat.mags])

    true_b_body = mag_sat.B_body
    if sim:
        # note: we want to use true body magnetic field of last iteration, not noisy sensor reading
        true_b_body = mag_sat.B_body - (sim.magNoises[iteration] * 1e-6)

    # torque (N*m) generated by magnetorquers: cross-product of moment with magnetic field
    torque = np.cross(moment, true_b_body)

    # computes the part of the torque vector that aligns with the magnetic field
    torque_projection = np.dot(torque, true_b_body) / np.linalg.norm(true_b_body)**2 * true_b_body
    # ensure torque is not generated in direction of magnetic field
    torque -= torque_projection

    # limit mag torques based on type (ferro or air)
    torque = np.clip(torque, -mag_sat.max_torque, mag_sat.max_torque)

    # calculate power output of magnetorquers = current output * operational voltage
    # power = Watts being used at this particular time
    power = np.abs(MAX_VOLTAGE * currents)
    # power = np.abs(currents * voltage_in) # TODO: should it be max or current voltage?
    
    if sim:
        # if we passed a sim object (we're running sim), store data
        sim.power_output[iteration] = np.array(power)
        sim.currents[iteration] = np.array(currents)
        sim.torques[iteration] = np.array(torque)
    
    # calculate quaternion and angular velocity derivatives from Equations of Motion
    q_dot, w_dot = eoms(quaternion, velocity, 0, torque, 0, dt, mag_sat.I_body, 0)
    # propagate state using Euler's method
    # find next state in time (based on current state, not sensor data)
    quaternion_new = normalize(quaternion + q_dot*dt)
    w_sat_new = velocity + w_dot*dt

    return quaternion_new, w_sat_new